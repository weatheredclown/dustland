# TypeScript `@ts-nocheck` Removal Roadmap

The first milestone removes `@ts-nocheck` from `ts-src/scripts/workbench.ts` and `ts-src/scripts/dustland-path.ts`. The build now succeeds with full type-checking on these files and the runtime tests still pass.

The remaining files with `@ts-nocheck` fall into three broad categories. The plan below sequences follow-up work so each step introduces the minimal set of new types and helpers.

## Current status snapshot

- **Last updated**: 2025-10-28 by automated agent.
- **Files remaining with `@ts-nocheck`**: 21 (9 core engine, 6 module bundles, 6 UI/tooling scripts). The count is generated by `rg "@ts-nocheck" ts-src -l | wc -l` and should trend downward after every milestone.
- **Shared helpers already typed**: combat queue utilities, dialog registries, and the workbench loader. Treat these files as reference implementations when introducing new ambient definitions.
- **Primary risks**: tight coupling on `globalThis`, ad-hoc event payloads, and duplicate literal schemas across modules. Each phase below includes mitigations that keep the churn manageable.

## 1. Core engine infrastructure

**Scope**: `ts-src/scripts/dustland-core.ts`, the `core/` directory (combat, dialog, effects, inventory, item-generator, module-behaviors, movement, npc, quests, trader), and orchestration files such as `dustland-engine.ts`, `dustland-nano.ts`, `procedural-map.ts`, `multiplayer.ts`, and `adventure-kit.ts`.

**Notes**
- These files share hundreds of globals that are currently declared implicitly. Capturing the common surface in ambient definitions will unblock multiple files at once.
- Several modules (combat, inventory, movement) mutate shared state; typed helpers that wrap `globalThis` access will keep the implementation similar to the pattern established in `workbench.ts`.

**Exit criteria**
- `ts-src/global.d.ts` exposes typed surfaces for the player model, NPC collections, inventory, quests, and the event bus.
- All files in `ts-src/scripts/core/` compile without `@ts-nocheck` and use shared helpers instead of raw `globalThis` access.
- `dustland-core.ts`, `dustland-engine.ts`, `procedural-map.ts`, and `multiplayer.ts` pass type-checking without suppressions.

**Suggested steps**
1. Extend `ts-src/global.d.ts` with structured interfaces for `player`, `NPCS`, `EventBus`, combat entities, and quest data so downstream code can reuse them. Track progress in a checklist that pairs each interface with the file that first consumes it.
2. Convert one subsystem at a time (for example `core/party.ts` → `core/movement.ts` → `dustland-core.ts`), replacing bare global reads with typed accessors. Start with files that already expose TypeScript types (party, inventory) to bootstrap the shared definitions.
3. Introduce lightweight utility modules (e.g., `ts-src/types/globals.ts`) if repeated casting becomes noisy. Favor pure functions that accept ambient state as parameters to simplify testing.
4. After each batch, run `npm test` and `npm run build` to ensure the interaction-heavy suites stay green before moving to the next subsystem.
5. Once the shared definitions stabilize, enable `strictNullChecks` in a throwaway branch to gauge remaining hotspots. Document any blockers in this roadmap before attempting to flip the flag globally.

## 2. Module data bundles

**Scope**: `ts-src/modules/*.module.ts`.

**Notes**
- These files export large literal objects. Most errors stem from implicit `any` usage and reliance on `globalThis` helpers (`findItemIndex`, `removeFromInv`, `addToInv`).
- Creating module-specific type aliases (for encounters, NPC definitions, loot tables) will make the literals self-documenting.

**Exit criteria**
- `ts-src/modules/types.ts` (or its successor) captures the shared schema for rooms, encounters, NPCs, dialog trees, loot tables, and triggers.
- Each module exports a typed object that satisfies the schema without resorting to `as any` casts.
- Global inventory helpers are invoked through typed wrappers or dependency injection, eliminating ambient lookups in module definitions.

**Suggested steps**
1. Add shared module schema types to `ts-src/modules/types.ts` (or extend the existing schema definitions) that describe rooms, NPCs, encounters, and dialog trees. Include a validation harness (simple Zod-like shape or JSON schema) to spot regressions as modules are refactored.
2. Replace the global helper lookups with the typed utilities introduced in the engine work, or inject them via function parameters when possible.
3. Remove `@ts-nocheck` one module at a time, starting with the smallest (e.g., `edge.module.ts`) to validate the schema before tackling larger story modules. Capture lessons learned in module-specific READMEs to accelerate the later conversions.
4. Coordinate module conversions with narrative designers so they can validate that loot tables and dialog variants still match the design intent.

## 3. UI and tooling scripts

**Scope**: `ts-src/scripts/ui/skin-manager.ts`, `ts-src/scripts/workbench.ts` (already typed), `ts-src/music-demo.ts`, `ts-src/scripts/dustland-nano.ts`, and `ts-src/scripts/adventure-kit.ts`.

**Notes**
- These scripts interact with the DOM and browser APIs. Typing them mostly involves annotating the DOM elements and defining ambient types for third-party libraries (Tone.js, Magenta, Nano dialog helpers).
- `music-demo.ts` is self-contained but large; treat it as a separate effort once the engine globals are in place.

**Exit criteria**
- All UI scripts compile without `@ts-nocheck`, rely on typed DOM helpers, and include inline documentation for tricky browser API interactions.
- External libraries (Tone.js, Magenta) are covered by ambient type declarations or vendored `.d.ts` files.
- Reusable UI state containers (theme settings, nano dialog state) expose explicit interfaces consumed by multiple files.

**Suggested steps**
1. Define DOM-centric utility types (e.g., `Nullable<T> = T | null`) and ambient declarations for external libraries in `global.d.ts` or dedicated `d.ts` files. Capture them in `tsconfig.json`'s `types` array so editors pick them up automatically.
2. Convert `skin-manager.ts` next—it primarily manipulates style properties and should compile once the CSS variable map is typed. Ensure all CSS custom properties referenced in TypeScript have corresponding entries in `dustland.css` to avoid runtime mismatches.
3. Address `dustland-nano.ts` and `adventure-kit.ts` after the engine globals are formalized, since they depend on the same shared APIs. Write lightweight integration tests that mount the primary UI flows in jsdom to catch regressions while typing.
4. Reserve `music-demo.ts` for last; split it into smaller helpers if needed to stay within manageable review size. Document any Tone.js abstractions so newcomers can trace signal flow quickly.

## Reporting cadence

- Update this roadmap after each merge that removes a `@ts-nocheck` header. Include the interface or helper introduced so future contributors can reuse it.
- Keep a running table (in this document or an adjacent `progress.md`) that maps file names to owners and planned sprint windows. This makes it easy to see which areas are blocked or ready for review.
- Celebrate intermediate wins—post a short note in the engineering channel when a subsystem is fully typed to reinforce the momentum.

### Recent progress log

| Date       | Summary |
| ---------- | ------- |
| 2025-10-29 | Introduced `scripts/core/globals.ts` to expose typed helpers (DustlandGlobals) and removed `@ts-nocheck` from `ts-src/scripts/core/item-generator.ts`. Updated UI entry points and tests to load the helper before exercising ItemGen. |
| 2025-10-28 | Removed `@ts-nocheck` from `ts-src/scripts/core/trader.ts` by introducing typed trader inventory helpers and stricter price calculations. Updated the global snapshot to reflect 21 files remaining. |
| 2024-05-12 | Recounted the remaining suppressions (24 total) and categorized them by subsystem so future work can be pulled in smaller batches. Added this progress log section to track future milestones inline. |

Following this sequence keeps each phase focused and maximizes reuse of newly introduced type definitions. The approach mirrors the conversions in `workbench.ts` and `dustland-path.ts`, so future migrations can lean on those patterns.

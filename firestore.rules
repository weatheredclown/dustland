rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function isSignedIn() {
      return request.auth != null;
    }

    function mapIdFromVersion(docId) {
      return docId.split('_')[0];
    }

    function mapRef(mapId) {
      return get(/databases/$(database)/documents/maps/$(mapId));
    }

    function isOwner(mapDoc) {
      return mapDoc.exists() && isSignedIn() && mapDoc.data.ownerId == request.auth.uid;
    }

    function shareRef(mapId, uid) {
      return get(/databases/$(database)/documents/shares/$(mapId + '_' + uid));
    }

    function shareRole(mapId) {
      let share = shareRef(mapId, request.auth.uid);
      return share.exists() ? share.data.role : null;
    }

    // Listing modules from the Adventure Kit relies on read access for owners,
    // editors (via shares), and public viewers.
    function canReadMap(mapDoc, mapId) {
      return mapDoc.exists()
        && (mapDoc.data.visibility == 'public'
          || isOwner(mapDoc)
          || (isSignedIn() && shareRef(mapId, request.auth.uid).exists()));
    }

    function canEditMap(mapDoc, mapId) {
      return canReadMap(mapDoc, mapId)
        && (isOwner(mapDoc) || shareRole(mapId) == 'editor');
    }

    function versionMapId(docId) {
      return request.resource != null && request.resource.data.moduleId != null
        ? request.resource.data.moduleId
        : mapIdFromVersion(docId);
    }

    match /maps/{mapId} {
      allow read: if canReadMap(resource, mapId);
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid;
      allow update: if canEditMap(resource, mapId);
      allow delete: if false;
    }

    match /mapVersions/{docId} {
      // Use stored moduleId to identify map for permissions, avoiding fragile ID parsing
      allow read: if canReadMap(mapRef(versionMapId(docId)), versionMapId(docId));

      // Enforce consistency between docId and payload, and check permissions on the referenced map
      allow create: if isSignedIn()
        && versionMapId(docId) + '_' + request.resource.data.versionId == docId
        && (canEditMap(mapRef(versionMapId(docId)), versionMapId(docId))
          || (!mapRef(versionMapId(docId)).exists()
            && request.resource.data.createdBy == request.auth.uid));

      // Permit re-saving an existing version when metadata is unchanged
      allow update: if isSignedIn()
        && request.resource.data.moduleId == resource.data.moduleId
        && request.resource.data.versionId == resource.data.versionId
        && request.resource.data.moduleId + '_' + request.resource.data.versionId == docId
        && canEditMap(mapRef(resource.data.moduleId), resource.data.moduleId);

      allow delete: if false;
    }

    match /shares/{docId} {
      // Use stored mapId/userId for permissions to avoid ID parsing issues
      allow read: if isSignedIn()
        && (request.auth.uid == resource.data.userId || isOwner(mapRef(resource.data.mapId)));

      allow create: if isSignedIn()
        && request.resource.data.mapId + '_' + request.resource.data.userId == docId
        && isOwner(mapRef(request.resource.data.mapId));

      allow delete: if isSignedIn()
        && (request.auth.uid == resource.data.userId || isOwner(mapRef(resource.data.mapId)));

      allow update: if false;
    }

    match /publicListings/{mapId} {
      allow read: if true;
      allow write: if isSignedIn() && isOwner(mapRef(mapId));
    }

    match /users/{uid} {
      allow read, write: if isSignedIn() && request.auth.uid == uid;
    }
  }
}

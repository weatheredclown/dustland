import assert from 'node:assert';
import { test } from 'node:test';
import fs from 'node:fs/promises';
import vm from 'node:vm';
import { createGameProxy } from './test-harness.js';

test('walking heals and updates party UI', async () => {
  const { context, document } = createGameProxy([]);
  context.Dustland = { effects: { tick: () => {} }, path: {}, actions: { startCombat: () => {} } };
  context.TILE = { ROAD: 0 };
  context.walkable = { 0: true };
  context.world = [ [0,0], [0,0] ];
  context.itemDrops = [];
  context.NPCS = [];
  context.interiors = {};
  context.tileEvents = [];
  context.clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  context.setPartyPos = () => {};
  context.footstepBump = () => {};
  context.checkAggro = () => {};
  context.checkRandomEncounter = () => {};
  context.updateHUD = () => {};
  context.centerCamera = () => {};
  const partyCode = await fs.readFile(new URL('../scripts/core/party.js', import.meta.url), 'utf8');
  vm.runInContext(partyCode, context);
  context.party.x = 0;
  context.party.y = 0;
  const moveCode = await fs.readFile(new URL('../scripts/core/movement.js', import.meta.url), 'utf8');
  vm.runInContext(moveCode, context);
  context.checkRandomEncounter = () => {};
  const mem = new context.Character('h', 'Hero', 'Role');
  mem.hp = 5; mem.maxHp = 10;
  context.party.join(mem);
  context.renderParty();
  const partyDiv = document.getElementById('party');
  assert.match(partyDiv.children[0].innerHTML, /HP 5\/10/);
  await context.move(1,0);
  assert.match(partyDiv.children[0].innerHTML, /HP 6\/10/);
});
